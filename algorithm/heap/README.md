# Heap-堆

## 特性

「堆」是一种「完全二叉树」的数据结构，通常使用数组实现。具备以下两种特性：

- 堆序性质：在最小堆中，对于任意节点i，其父节点的值小于等于它自身的值。在最大堆中，则相反，父节点的值大于等于它自身的值。
- 完全二叉树性质：除了最底层，堆中的每层都是满的，且最底层节点尽可能从左到右填充。


## 实现

### 表示

对于给定节点索引i，相关节点索引：

- 父节点：Math.floor((i - 1) / 2)
- 左子节点：2 * i + 1
- 右子节点：2 * i + 2

### 堆化

将一个无序的数组转化成符合堆性质的堆的过程。通常有两种堆化操作：

- 自底向上（Bottom-up Heapify）：从数组的最后一个节点开始，逐个向上遍历数组，对每个节点执行下滤操作，将当前节点及其子树调整为一个合法的堆。这种堆化操作确保了堆的局部性质，即每个节点的子树都满足堆序性质。在堆排序等场景中，自底向上堆化通常用于构建初始堆。

- 自顶向下（Top-down Heapify）：从堆顶开始，逐个向下遍历数组，对每个节点执行上滤操作，将当前节点及其父节点调整为一个合法的堆。这种堆化操作通常在插入元素到堆中时使用，确保新插入的元素能够被正确地放置到合适的位置，以维持堆的性质。

备注：

  - 非叶子节点：指的是在树结构中，除了叶子节点以外的节点。在堆的表示中，非叶子节点是具有子节点的节点，它们不是堆的最后一层
  - 堆顶：根节点，数组的首元素
  - 堆底：数组的最后一个元素


### 元素入堆

- 将元素添加至堆底
- 从入堆节点位置开始，执行自底向上的堆化操作

### 元素出堆

- 交换堆顶与堆底元素
- 交换完毕，删除堆底元素
- 从根节点开始，执行自顶向下的堆化操作

### 堆的常见操作

- push()：元素入堆	
- pop()：堆顶元素出堆	
- peek()：访问堆顶元素（对于大 / 小顶堆分别为最大 / 小值）	
- size()：获取堆的元素数量	
- isEmpty()：判断堆是否为空	

## 应用场景


堆可以用于许多不同的场景，其中一些主要的应用包括：

- 优先队列（Priority Queue）：堆经常被用作优先队列的实现。在优先队列中，元素被赋予不同的优先级，并按照优先级顺序进行插入和删除操作。由于最小堆的性质，它特别适合用于实现最高优先队列，其中具有最高优先级的元素始终处于队列的前面。

- 堆排序（Heap Sort）：堆排序是一种原地、稳定的排序算法，它利用堆的性质进行排序。堆排序的时间复杂度为 O(n log n)，并且不需要额外的空间，因此在某些情况下比其他排序算法更有优势。

- 图算法：在图算法中，堆经常被用来实现 Dijkstra 算法和 Prim 算法。在 Dijkstra 算法中，堆被用来维护到每个顶点的最短路径的估计值；在 Prim 算法中，堆被用来选择最小生成树的下一个顶点。

- 调度器和任务调度：堆可以被用来实现调度器和任务调度算法。通过维护任务的优先级，并按照优先级进行调度，可以实现高效的任务调度和资源管理。

- 中位数查找：在动态数据流中，堆可以用来实现中位数查找算法。通过维护一个最大堆和一个最小堆，并保持它们的大小相等或相差最多一个元素，可以在 O(log n) 的时间内找到中位数。

- 事件驱动系统：在事件驱动系统中，堆可以用来实现定时器和任务调度器。通过维护事件的触发时间，并按照时间顺序进行调度，可以实现高效的事件驱动和任务执行。